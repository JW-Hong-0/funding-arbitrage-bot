# 모듈러 봇 잠재적 문제점 분석 보고서

## 1. 개요
본 문서는 `modular_bot`의 안정성 및 잠재적 위험 요소를 분석하고, 향후 업데이트 시 고려해야 할 사항들을 정리하는 것을 목표로 합니다.

---

## 2. 치명적 문제 (High Priority)

### 2.1. GRVT 주문 생성 후 추적 실패 문제
- **원인**: 현재 사용 중인 `shared_crypto_lib`의 GRVT `create_order` 함수는, 주문 생성 API가 불안정한 응답(예: `id='0x00'`)을 반환했을 때 이를 검증하고 재시도하는 로직이 없습니다. (이전 레거시 파일에는 있었던 기능)
- **결과**: 유효하지 않은 주문 ID가 `TradingService`로 전달되어 주문 추적이 누락됩니다. 해당 주문이 실제로 체결되더라도 봇은 이를 인지하지 못해 헤징(반대매매) 주문을 실행하지 않으므로, 거래소 간 포지션 불일치가 발생합니다.
- **권장 해결 방안**: 레거시 `grvt_api.py`에 있었던 것처럼, `create_order` 함수 내에 주문 생성 실패 또는 불안정 응답 시, 잠시 후 `fetch_open_orders`를 통해 주문이 정상적으로 생성되었는지 확인하는 검증 로직을 다시 구현해야 합니다.

---

## 3. 아키텍처 및 시스템 리스크 (Medium Priority)

### 3.1. 데이터 업데이트 실패 시의 방어 로직 부재
- **문제점**: `AssetManager`나 `MonitoringService`가 거래소로부터 최신 자산, 포지션, 시세 데이터를 가져오는 데 실패하더라도, 에러 로그만 기록할 뿐 봇의 메인 루프는 계속 실행됩니다.
- **위험성**: 오래되거나 유효하지 않은 데이터를 기반으로 거래 판단을 내리게 되어, 잘못된 주문을 실행하거나 자산 불일치를 심화시킬 수 있습니다.
- **권장 해결 방안**:
    - **Health Check**: 각 거래소 API와의 연결 상태 및 데이터 수신 시간을 주기적으로 체크하는 '헬스 체크' 기능을 도입합니다.
    - **Circuit Breaker**: 특정 시간 동안 데이터 업데이트가 계속 실패하면, 신규 주문을 중단하고 모든 포지션을 안전하게 종료하거나 관리자에게 즉시 알림을 보내는 '서킷 브레이커' 패턴을 적용하는 것을 고려해야 합니다.

### 3.2. 미관리 주문 처리 로직의 경쟁 상태(Race Condition)
- **문제점**: `TradingService`가 추적하지 않던 주문을 나중에 발견하여 "입양(adopt)"하는 로직은 근본적으로 경쟁 상태에 놓여있습니다. 즉, 봇이 주문을 '입양'하기 직전에 체결이 발생할 수 있습니다.
- **위험성**: 이 경우, 봇은 체결 사실을 놓친 채로 포지션 상태를 기록하게 되어 헤징 로직이 실행되지 않습니다. (2.1 문제의 결과와 동일)
- **권장 해결 방안**: 이 문제는 2.1 문제가 해결되면 대부분 해소됩니다. 모든 주문이 생성 시점부터 안정적으로 추적된다면, "입양" 로직이 실행될 경우가 크게 줄어듭니다.

---

## 4. 거래소별 구현 및 외부 의존성 리스크 (Medium Priority)

### 4.1. 외부 라이브러리(pysdk) 및 API 변경 가능성
- **문제점**: 봇의 핵심 기능은 `pysdk`와 각 거래소(GRVT, Lighter)의 API 명세에 강하게 의존하고 있습니다.
- **위험성**: `pysdk`가 업데이트되거나 거래소 API의 응답 형식, 주소, 정책 등이 예고 없이 변경될 경우, 봇의 특정 기능(주문, 조회 등)이 예기치 않게 실패할 수 있습니다.
- **권장 해결 방안**:
    - `pysdk`의 버전을 고정하여 관리하고, 업데이트 시에는 변경 내역을 충분히 검토한 후 테스트를 거쳐 반영해야 합니다.
    - 각 거래소 API의 변경 공지를 주기적으로 확인하는 프로세스를 갖추는 것이 좋습니다.

### 4.2. Lighter, Variational 거래소의 잠재적 리스크
- **문제점**: 현재 GRVT에서 발견된 '불안정한 주문 생성 응답'과 같은 문제가 Lighter나 Variational 거래소에서도 존재할 수 있습니다.
- **위험성**: 만약 다른 거래소에서도 유사한 API 특성이 있다면, GRVT와 동일한 포지션 불일치 문제가 재현될 수 있습니다.
- **권장 해결 방안**: Lighter와 Variational의 `create_order` 함수 또한 GRVT와 같이 주문 생성 후 실제 주문이 잘 접수되었는지 확인하는 검증 로직을 추가하는 것을 검토해야 합니다.

---

## 5. 거래 전략 및 로직 리스크 (Low to Medium Priority)

### 5.1. 포지션 불일치 복구 로직의 복잡성
- **위치**: `trading_service.py`의 `_reconcile_state` 함수
- **문제점**: 포지션 불일치(`PARTIAL_HEDGE`)가 발생했을 때 이를 자동으로 복구하려는 로직은 매우 복잡하며 다양한 엣지 케이스를 가집니다.
- **위험성**: 만약 이 복구 로직에 버그가 있다면, 문제를 해결하는 것이 아니라 오히려 불일치를 더 심화시키거나 의도치 않은 거래를 유발할 수 있습니다.
- **권장 해결 방안**:
    - 복구 로직이 실행될 때마다 슬랙, 텔레그램 등으로 관리자에게 상세한 내용을 알리는 기능을 추가하여 즉시 인지할 수 있도록 하는 것이 좋습니다.
    - 다양한 불일치 시나리오에 대한 단위 테스트 또는 시뮬레이션 테스트를 강화하여 로직의 안정성을 확보해야 합니다.

### 5.2. 설정값(Config) 관리의 복잡성
- **문제점**: `.env`와 `config.py`에 `GRVT_USE_POSITION_CONFIG`, `STRATEGY_SWITCH_DELTA_BPS` 등 다양한 설정값들이 존재합니다. 이들의 의미를 정확히 파악하지 않고 변경할 경우 봇이 비정상적으로 동작할 수 있습니다.
- **위험성**: 사소한 설정 실수가 큰 자산 손실로 이어질 수 있습니다.
- **권장 해결 방안**: 중요한 설정값들에 대해서는 주석을 통해 각 설정이 어떤 역할을 하고, 어떤 값의 범위를 가지며, 변경 시 어떤 영향을 주는지 명확하게 문서화하는 것이 필요합니다.
